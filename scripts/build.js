// build the package in the current working directory

process.env.NODE_ENV = 'production';

const {createHash} = require('crypto');
const readFileSync = require('fs').readFileSync;
const readdirSync = require('fs').readdirSync;
const unlinkSync = require('fs').unlinkSync;
const writeFileSync = require('fs').writeFileSync;
const {lsrSync} = require('lsr');
const babel = require('babel-core');
const {sync: spawnSync} = require('cross-spawn');

const cwd = process.cwd();
const rootPkg = require('../package.json');
const pkg = require(cwd + '/package.json');

// .last_build
const buildHash = createHash('sha512');
const IGNORED_NAMES = ['.cache', 'lib', 'node_modules', '.last_build'];
lsrSync(cwd, {
  filter(entry) {
    return !IGNORED_NAMES.includes(entry.name);
  },
}).forEach(entry => {
  if (entry.isFile()) {
    buildHash.update(readFileSync(entry.fullPath));
  }
});
Object.keys(pkg.dependencies || {})
  .concat(Object.keys(pkg.devDependencies || {}))
  .sort()
  .filter(name => !rootPkg.dependencies[name] && !rootPkg.devDependencies[name])
  .forEach(name => {
    buildHash.update(
      readFileSync(
        __dirname + '/../packages/' + name.split('/').pop() + '/.last_build',
      ),
    );
  });

const buildHashDigest = buildHash.digest('hex');
if (!process.argv.includes('--force')) {
  try {
    const lastBuild = readFileSync(cwd + '/.last_build', 'utf8');
    if (lastBuild.trim() === buildHashDigest) {
      process.exit(0);
    }
  } catch (ex) {
    if (ex.code !== 'ENOENT') {
      throw ex;
    }
  }
}

console.log('building ' + pkg.name);

readdirSync(cwd).forEach(entry => {
  try {
    if (/\@autogenerated\b/.test(readFileSync(cwd + '/' + entry, 'utf8'))) {
      unlinkSync(cwd + '/' + entry);
    }
  } catch (ex) {
    if (ex.code !== 'EISDIR') {
      throw ex;
    }
  }
});

// tsc -p tsconfig.build.json
const result = spawnSync('tsc', ['-p', 'tsconfig.build.json'], {
  stdio: 'inherit',
});
if (result.status !== 0) {
  console.error('Failed to build ' + cwd.split('/').pop());
  process.exit(1);
}

lsrSync(cwd + '/lib').forEach(entry => {
  if (entry.isFile() && /\.jsx?$/.test(entry.path)) {
    const hasDefaultExport = /\bexport default\b/.test(
      readFileSync(entry.fullPath.replace(/\.jsx?$/, '.d.ts'), 'utf8'),
    );
    const isPublic = /\@public\b/.test(readFileSync(entry.fullPath, 'utf8'));
    writeFileSync(
      entry.fullPath.replace(/\.jsx$/, '.js'),
      babel.transformFileSync(entry.fullPath, {
        babelrc: false,
        presets: [
          pkg['@authentication/target'] === 'browser'
            ? require.resolve('@moped/babel-preset/browser')
            : require.resolve('@moped/babel-preset/server'),
        ],
      }).code,
    );
    if (/\.jsx$/.test(entry.fullPath)) {
      unlinkSync(entry.fullPath);
    }
    if (isPublic) {
      console.log('isPublic', {
        path: entry.path,
        js: cwd + '/' + entry.path.substr(2).replace(/\.jsx$/, '.js'),
        ts: cwd + '/' + entry.path.substr(2).replace(/\.jsx?$/, '.d.ts'),
      });
      const path = entry.path.substr(2).replace(/\.jsx?$/, '');
      writeFileSync(
        cwd + '/' + entry.path.substr(2).replace(/\.jsx$/, '.js'),
        "// @autogenerated\n\nmodule.exports = require('./lib/" + path + "');",
      );
      writeFileSync(
        cwd + '/' + entry.path.substr(2).replace(/\.jsx?$/, '.d.ts'),
        "// @autogenerated\n\nexport * from './lib/" +
          path +
          "';\n" +
          (hasDefaultExport ? `export {default} from './lib/${path}';` : ''),
      );
    }
  }
});
writeFileSync(cwd + '/.last_build', buildHashDigest);
