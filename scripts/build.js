// build the package in the current working directory

process.env.NODE_ENV = 'production';

const {relative} = require('path');
const {createHash} = require('crypto');
const dirname = require('path').dirname;
const readFileSync = require('fs').readFileSync;
const unlinkSync = require('fs').unlinkSync;
const writeFileSync = require('fs').writeFileSync;
const {lsrSync} = require('lsr');
const babel = require('@babel/core');
const {sync: spawnSync} = require('cross-spawn');
const mkdirp = require('mkdirp').sync;

const cwd = process.cwd();
const pkg = require(cwd + '/package.json');

// .last_build
const buildHash = createHash('sha512');
const IGNORED_NAMES = ['.cache', 'lib', 'node_modules', '.last_build'];
lsrSync(cwd, {
  filter(entry) {
    return !IGNORED_NAMES.includes(entry.name);
  },
}).forEach((entry) => {
  if (entry.isFile()) {
    buildHash.update(readFileSync(entry.fullPath));
  }
});
Object.keys(pkg.dependencies || {})
  .concat(Object.keys(pkg.devDependencies || {}))
  .sort()
  .filter((name) => name.startsWith('@authentication'))
  .forEach((name) => {
    buildHash.update(
      readFileSync(
        __dirname + '/../packages/' + name.split('/').pop() + '/.last_build',
      ),
    );
  });

const buildHashDigest = buildHash.digest('hex');
if (!process.argv.includes('--force')) {
  try {
    const lastBuild = readFileSync(cwd + '/.last_build', 'utf8');
    if (lastBuild.trim() === buildHashDigest) {
      process.exit(0);
    }
  } catch (ex) {
    if (ex.code !== 'ENOENT') {
      throw ex;
    }
  }
}

console.log('building ' + pkg.name);

lsrSync(cwd, {
  filter: (e) => e.name !== 'node_modules' && e.name !== 'src',
}).forEach((entry) => {
  if (!entry.isFile()) return;
  try {
    if (/\@autogenerated\b/.test(readFileSync(entry.fullPath, 'utf8'))) {
      unlinkSync(entry.fullPath);
    }
  } catch (ex) {
    if (ex.code !== 'EISDIR') {
      throw ex;
    }
  }
});

// tsc -p tsconfig.build.json
const result = spawnSync('tsc', ['-p', 'tsconfig.build.json'], {
  stdio: 'inherit',
});
if (result.status !== 0) {
  console.error('Failed to build ' + cwd.split('/').pop());
  process.exit(1);
}

lsrSync(cwd + '/lib').forEach((entry) => {
  if (entry.isFile() && /\.jsx?$/.test(entry.path)) {
    const isPublic = /\@public\b/.test(readFileSync(entry.fullPath, 'utf8'));
    const hasDefault = /\bexport default\b/.test(
      readFileSync(entry.fullPath.replace(/\.jsx?$/, '.d.ts'), 'utf8'),
    );
    writeFileSync(
      entry.fullPath.replace(/\.jsx$/, '.js'),
      babel.transformFileSync(entry.fullPath, {
        babelrc: false,
        presets: [
          pkg['@authentication/target'] === 'browser'
            ? {
                presets: [
                  // Latest stable ECMAScript features
                  [
                    require.resolve('@babel/preset-env'),
                    {
                      targets: {
                        // we don't support browsers without generator support
                        // because we "exclude" @babel/plugin-transform-regenerator
                        // adding it in would require our own custom version with
                        // a local version of regenerator-runtime
                        browsers: [
                          '>0.2%',
                          'not dead',
                          'not ie 11', // 1.43% global market share, doesn't support generators
                          'not chrome 49', // 0.52% global market share, doesn't support generators
                        ],
                        node: '10',
                      },
                      bugfixes: true,
                      modules: 'cjs',
                      exclude: ['@babel/plugin-transform-regenerator'],
                    },
                  ],
                  // JSX
                  require.resolve('@babel/preset-react'),
                ],
              }
            : {
                presets: [
                  // ES features necessary for user's Node version
                  [
                    require.resolve('@babel/preset-env'),
                    {
                      targets: {
                        node: '10',
                      },
                      bugfixes: true,
                      modules: 'cjs',
                      exclude: ['@babel/plugin-transform-regenerator'],
                    },
                  ],
                  // JSX
                  require.resolve('@babel/preset-react'),
                ],
              },
        ],
      }).code,
    );
    if (/\.jsx$/.test(entry.fullPath)) {
      unlinkSync(entry.fullPath);
    }
    if (isPublic) {
      mkdirp(
        dirname(cwd + '/' + entry.path.substr(2).replace(/\.jsx$/, '.js')),
      );
      let moduleName = relative(
        dirname(entry.path),
        `./lib/${entry.path
          .substr(2)
          .replace(/\.jsx?$/, '')
          .replace(/\/index$/, '')}`,
      ).replace(/\\/g, '/');
      if (moduleName[0] !== '.') moduleName = `./${moduleName}`;
      writeFileSync(
        cwd + '/' + entry.path.substr(2).replace(/\.jsx$/, '.js'),
        `// @autogenerated\n\nmodule.exports = require('${moduleName}');\n`,
      );
      writeFileSync(
        cwd + '/' + entry.path.substr(2).replace(/\.jsx?$/, '.d.ts'),
        `// @autogenerated\n\nexport * from '${moduleName}';${
          hasDefault ? `\nexport {default} from '${moduleName}';` : ``
        }\n`,
      );
    }
  }
});
writeFileSync(cwd + '/.last_build', buildHashDigest);
